using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Macaron.FluentEnum.Tests;

[TestFixture]
public class EnumExtensionsGeneratorTests
{
    private static void AssertGeneratedCode(
        string sourceCode,
        string expected,
        out ImmutableArray<Diagnostic> diagnostics
    )
    {
        (diagnostics, var generatedCode) = CompileAndGetResults(sourceCode);

        Assert.That(generatedCode.ReplaceLineEndings(), Is.EqualTo(expected.ReplaceLineEndings()));
    }

    private static void AssertGeneratedCode(string sourceCode, string expected)
    {
        var (_, generatedCode) = CompileAndGetResults(sourceCode);

        Assert.That(generatedCode.ReplaceLineEndings(), Is.EqualTo(expected.ReplaceLineEndings()));
    }

    private static (ImmutableArray<Diagnostic> diagnostics, string generatedCode) CompileAndGetResults(string sourceCode)
    {
        var references = AppDomain
            .CurrentDomain
            .GetAssemblies()
            .Where(assembly => !assembly.IsDynamic && !string.IsNullOrWhiteSpace(assembly.Location))
            .Select(assembly => MetadataReference.CreateFromFile(assembly.Location))
            .Cast<MetadataReference>()
            .ToImmutableArray();

        var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
        var compilation = CSharpCompilation.Create(
            assemblyName: "Macaron.PropertyAccessor.Tests",
            syntaxTrees: [syntaxTree],
            references: references,
            options: new CSharpCompilationOptions(
                outputKind: OutputKind.DynamicallyLinkedLibrary,
                nullableContextOptions: NullableContextOptions.Enable
            )
        );

        var generator = new EnumExtensionsGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);

        var result = driver.RunGenerators(compilation).GetRunResult().Results.Single();
        var generatedSources = result.GeneratedSources;
        // 0번은 EnumExtensionsAttribute
        var generatedCode = generatedSources.Length > 1 ? generatedSources[1].SourceText.ToString() : "";

        var allDiagnostics = compilation.GetDiagnostics()
            .Concat(result.Diagnostics)
            .ToImmutableArray();

        return (allDiagnostics, generatedCode);
    }

    [Test]
    public void Should_GenerateExtensions_When_HasFluentAttribute()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.FluentEnum.Tests;

            [Fluent]
            public enum Foo
            {
                None,

                Bar,
                Baz,
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.FluentEnum.Tests
            {
                public static class FooExtensions
                {
                    public static bool Is(this global::Macaron.FluentEnum.Tests.Foo foo, global::Macaron.FluentEnum.Tests.Foo value)
                    {
                        return foo == value;
                    }

                    public static bool IsNone(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return foo == global::Macaron.FluentEnum.Tests.Foo.None;
                    }

                    public static bool IsBar(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return foo == global::Macaron.FluentEnum.Tests.Foo.Bar;
                    }

                    public static bool IsBaz(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return foo == global::Macaron.FluentEnum.Tests.Foo.Baz;
                    }
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateHasExtensions_When_HasFluentAttributeWithFlagsAttribute()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using System;

            namespace Macaron.FluentEnum.Tests;

            [Fluent]
            [Flags]
            public enum Foo
            {
                None = 0x00,

                Bar = 0x01,
                Baz = 0x02,
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.FluentEnum.Tests
            {
                public static class FooExtensions
                {
                    public static bool Is(this global::Macaron.FluentEnum.Tests.Foo foo, global::Macaron.FluentEnum.Tests.Foo value)
                    {
                        return foo == value;
                    }

                    public static bool IsNone(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return foo == global::Macaron.FluentEnum.Tests.Foo.None;
                    }

                    public static bool IsBar(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return foo == global::Macaron.FluentEnum.Tests.Foo.Bar;
                    }

                    public static bool IsBaz(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return foo == global::Macaron.FluentEnum.Tests.Foo.Baz;
                    }

                    public static bool Has(this global::Macaron.FluentEnum.Tests.Foo foo, global::Macaron.FluentEnum.Tests.Foo value)
                    {
                        return (foo & value) != 0;
                    }

                    public static bool HasNone(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return (foo & global::Macaron.FluentEnum.Tests.Foo.None) != 0;
                    }

                    public static bool HasBar(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return (foo & global::Macaron.FluentEnum.Tests.Foo.Bar) != 0;
                    }

                    public static bool HasBaz(this global::Macaron.FluentEnum.Tests.Foo foo)
                    {
                        return (foo & global::Macaron.FluentEnum.Tests.Foo.Baz) != 0;
                    }
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateExtensions_When_HasFluentAttributeWithoutNamespace()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using Macaron.FluentEnum;

            [Fluent]
            public enum Foo
            {
                None,

                Bar,
                Baz,
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            public static class FooExtensions
            {
                public static bool Is(this global::Foo foo, global::Foo value)
                {
                    return foo == value;
                }

                public static bool IsNone(this global::Foo foo)
                {
                    return foo == global::Foo.None;
                }

                public static bool IsBar(this global::Foo foo)
                {
                    return foo == global::Foo.Bar;
                }

                public static bool IsBaz(this global::Foo foo)
                {
                    return foo == global::Foo.Baz;
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateExtensionsCorrectly_When_HasFluentAttributeInNestedType()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.FluentEnum.Tests;

            public class Foo
            {
                [Fluent]
                public enum Bar
                {
                    None,

                    Baz,
                    Qux,
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.FluentEnum.Tests
            {
                public static class Foo_BarExtensions
                {
                    public static bool Is(this global::Macaron.FluentEnum.Tests.Foo.Bar bar, global::Macaron.FluentEnum.Tests.Foo.Bar value)
                    {
                        return bar == value;
                    }

                    public static bool IsNone(this global::Macaron.FluentEnum.Tests.Foo.Bar bar)
                    {
                        return bar == global::Macaron.FluentEnum.Tests.Foo.Bar.None;
                    }

                    public static bool IsBaz(this global::Macaron.FluentEnum.Tests.Foo.Bar bar)
                    {
                        return bar == global::Macaron.FluentEnum.Tests.Foo.Bar.Baz;
                    }

                    public static bool IsQux(this global::Macaron.FluentEnum.Tests.Foo.Bar bar)
                    {
                        return bar == global::Macaron.FluentEnum.Tests.Foo.Bar.Qux;
                    }
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateExtensionsCorrectly_When_HasFluentAttributeInGenericNestedType()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.FluentEnum.Tests;

            public interface IQux;

            public class Foo<T, TQux>
                where T : class
                where TQux : IQux
            {
                public class Bar<TBar>
                    where TBar : struct
                {
                    [Fluent]
                    public enum Baz
                    {
                        None,
                    }
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.FluentEnum.Tests
            {
                public static class Foo_2_Bar_1_BazExtensions
                {
                    public static bool Is<T, TQux, TBar>(this global::Macaron.FluentEnum.Tests.Foo<T, TQux>.Bar<TBar>.Baz baz, global::Macaron.FluentEnum.Tests.Foo<T, TQux>.Bar<TBar>.Baz value)
                        where T : class
                        where TQux : global::Macaron.FluentEnum.Tests.IQux
                        where TBar : struct
                    {
                        return baz == value;
                    }

                    public static bool IsNone<T, TQux, TBar>(this global::Macaron.FluentEnum.Tests.Foo<T, TQux>.Bar<TBar>.Baz baz)
                        where T : class
                        where TQux : global::Macaron.FluentEnum.Tests.IQux
                        where TBar : struct
                    {
                        return baz == global::Macaron.FluentEnum.Tests.Foo<T, TQux>.Bar<TBar>.Baz.None;
                    }
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateExtensionsCorrectly_When_HasFluentAttributeInGenericNestedTypeWithoutNamespace()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using Macaron.FluentEnum;

            public interface IQux;

            public class Foo<T, TQux>
                where T : class
                where TQux : IQux
            {
                public class Bar<TBar>
                    where TBar : struct
                {
                    [Fluent]
                    public enum Baz
                    {
                        None,
                    }
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            public static class Foo_2_Bar_1_BazExtensions
            {
                public static bool Is<T, TQux, TBar>(this global::Foo<T, TQux>.Bar<TBar>.Baz baz, global::Foo<T, TQux>.Bar<TBar>.Baz value)
                    where T : class
                    where TQux : global::IQux
                    where TBar : struct
                {
                    return baz == value;
                }

                public static bool IsNone<T, TQux, TBar>(this global::Foo<T, TQux>.Bar<TBar>.Baz baz)
                    where T : class
                    where TQux : global::IQux
                    where TBar : struct
                {
                    return baz == global::Foo<T, TQux>.Bar<TBar>.Baz.None;
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateExtensionsCorrectly_When_GenericNestedTypeHasDuplicatedTypeParameterNames()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.FluentEnum.Tests;

            public interface IQux;

            public class Foo<T, TQux>
                where T : class, new()
                where TQux : IQux
            {
                public class Bar<T>
                    where T : struct
                {
                    [Fluent]
                    public enum Baz
                    {
                        None,
                    }
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.FluentEnum.Tests
            {
                public static class Foo_2_Bar_1_BazExtensions
                {
                    public static bool Is<T0, T1, T2>(this global::Macaron.FluentEnum.Tests.Foo<T0, T1>.Bar<T2>.Baz baz, global::Macaron.FluentEnum.Tests.Foo<T0, T1>.Bar<T2>.Baz value)
                        where T0 : class, new()
                        where T1 : global::Macaron.FluentEnum.Tests.IQux
                        where T2 : struct
                    {
                        return baz == value;
                    }

                    public static bool IsNone<T0, T1, T2>(this global::Macaron.FluentEnum.Tests.Foo<T0, T1>.Bar<T2>.Baz baz)
                        where T0 : class, new()
                        where T1 : global::Macaron.FluentEnum.Tests.IQux
                        where T2 : struct
                    {
                        return baz == global::Macaron.FluentEnum.Tests.Foo<T0, T1>.Bar<T2>.Baz.None;
                    }
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateExtensionsCorrectly_When_GenericNestedTypeHasDuplicatedTypeParameterNamesWithoutNamespace()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using Macaron.FluentEnum;

            public interface IQux;

            public class Foo<T, TQux>
                where T : class, new()
                where TQux : IQux
            {
                public class Bar<T>
                    where T : struct
                {
                    [Fluent]
                    public enum Baz
                    {
                        None,
                    }
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            public static class Foo_2_Bar_1_BazExtensions
            {
                public static bool Is<T0, T1, T2>(this global::Foo<T0, T1>.Bar<T2>.Baz baz, global::Foo<T0, T1>.Bar<T2>.Baz value)
                    where T0 : class, new()
                    where T1 : global::IQux
                    where T2 : struct
                {
                    return baz == value;
                }

                public static bool IsNone<T0, T1, T2>(this global::Foo<T0, T1>.Bar<T2>.Baz baz)
                    where T0 : class, new()
                    where T1 : global::IQux
                    where T2 : struct
                {
                    return baz == global::Foo<T0, T1>.Bar<T2>.Baz.None;
                }
            }

            """
        );
    }

    [Test]
    public void Should_GenerateInternalExtensions_When_AccessibilityIsInternal()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.FluentEnum.Tests;

            internal class Foo
            {
                [Fluent]
                public enum Bar
                {
                    None,

                    Baz,
                    Qux,
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.FluentEnum.Tests
            {
                internal static class Foo_BarExtensions
                {
                    public static bool Is(this global::Macaron.FluentEnum.Tests.Foo.Bar bar, global::Macaron.FluentEnum.Tests.Foo.Bar value)
                    {
                        return bar == value;
                    }

                    public static bool IsNone(this global::Macaron.FluentEnum.Tests.Foo.Bar bar)
                    {
                        return bar == global::Macaron.FluentEnum.Tests.Foo.Bar.None;
                    }

                    public static bool IsBaz(this global::Macaron.FluentEnum.Tests.Foo.Bar bar)
                    {
                        return bar == global::Macaron.FluentEnum.Tests.Foo.Bar.Baz;
                    }

                    public static bool IsQux(this global::Macaron.FluentEnum.Tests.Foo.Bar bar)
                    {
                        return bar == global::Macaron.FluentEnum.Tests.Foo.Bar.Qux;
                    }
                }
            }

            """
        );
    }

    [Test]
    public void Should_NotGenerateExtensions_When_AccessibilityIsNotPublicOrInternal()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.FluentEnum.Tests;

            public class Foo
            {
                [Fluent]
                private enum Bar
                {
                    None,

                    Baz,
                    Qux,
                }
            }
            """,
            expected: "",
            out var diagnostics
        );

        Assert.That(diagnostics, Has.Some.Matches<Diagnostic>(diagnostic => diagnostic.Id == "MAFE0001"));
    }
}
